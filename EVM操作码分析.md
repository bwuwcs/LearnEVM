# EVM操作码分析

> //空栈
>
> stack[]
>
> //1为栈底，3为栈顶
>
> stack[1,2,3]
>
> //空存储
>
> store{}

---

### 2. solidity合约:存储一个变量

```
pragma solidity ^0.4.11;
contract C {
    uint256 a;
    function C() {
      a = 1;
    }
}
```
字节码:

```
6080604052348015600f57600080fd5b50
60 01 60 00 81 90 55 50 60 35 80 60 25 60 00 39 60 00 f3 00 60 80 60 40 52 60 00 80 fd 00 a1 65 62 7a 7a 72 30 58 20 e5 10 1d 3a 20 e5 db a3 9d cb f8 dc 63 c4 65 2b c6 83 b1 a2 ff d2 5c 15 0c ea eb b0 34 fa 03 f2 00 29
```

EVM依次读入这个16进制数字，60 80 60 40 .... ，首先解析第一个字节“60”,从汇编指令集中查询该值对应的指令，60对应的指令是"push"，因为push指令后需要一个输入参数，因此后面的字节"80"是该push指令的参数，然后继续解析第三个个"60"。

[汇编指令集](/EVM操作码表.md)

根据该指令集，对于上面的字节码可以翻译出对应的汇编指令代码：

汇编代码

	PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH1 0xF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP 
	PUSH1 0x1 PUSH1 0x0 DUP2 SWAP1 SSTORE POP PUSH1 0x35 DUP1 PUSH1 0x25 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN STOP PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT STOP LOG1 PUSH6 0x627A7A723058 KECCAK256 0xe5 LT SAR GASPRICE KECCAK256 0xe5 0xdb LOG3 SWAP14 0xcb 0xf8 0xdc PUSH4 0xC4652BC6 DUP4 0xb1 LOG2 SELFDESTRUCT 0xd2 0x5c ISZERO 0xc 0xea 0xeb 0xb0 CALLVALUE STATICCALL SUB CALLCODE STOP 0x29 

a=1字节码`60 01 60 00 81 90 55 50` 汇编指令`PUSH1 0x1 PUSH1 0x0 DUP2 SWAP1 SSTORE POP`

```
//60 01:将1压入栈中
PUSH1 0x01
	stack[0x01]
//60 00:将0压如栈中
PUSH1 0x00
	stack[0x01,0x00]
//81:复制栈中的第二项
DUP2
	stack[0x01,0x00,0x01]
//90:交换栈顶的两项数据
swap1
	stack[0x00,0x01,0x01]
//55:将数值0x01存储在0x00的位置上
sstore
  	stack[0x01]
  	store{0x00 => 0x01}
// 50:pop丢弃栈顶数据
pop
  	stack[]
  	store{0x00 => 0x01}
```

Solidity已经决定将状态变量`uint256 a`保存在`0x0`的位置上。其他语言完全可以选择将状态变量存储在其他的任何位置上。

---

### 3. solidity智能合约：存储两个变量

```
pragma solidity ^0.4.11;
contract C {
    uint256 a;
    uint256 b;
    function C() {
      a = 1;
      b = 2;
    }
}
```

字节代码:
```
6080604052348015600f57600080fd5b50
60016000819055506002600181905550603580602d6000396000f3006080604052600080fd00a165627a7a72305820794bf4fdc6e6537715b50eab45d4747267f34c59e087f96ff1fad575399095ab0029
```
汇编代码:
```
PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH1 0xF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x1 PUSH1 0x0 DUP2 SWAP1 SSTORE POP PUSH1 0x2 PUSH1 0x1 DUP2 SWAP1 SSTORE POP PUSH1 0x35 DUP1 PUSH1 0x2D PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN STOP PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT STOP LOG1 PUSH6 0x627A7A723058 KECCAK256 PUSH26 0x4BF4FDC6E6537715B50EAB45D4747267F34C59E087F96FF1FAD5 PUSH22 0x399095AB002900000000000000000000000000000000 
```


a=1,b=2字节码`60016000819055506002600181905550` 汇编指令`PUSH1 0x1 PUSH1 0x0 DUP2 SWAP1 SSTORE POP PUSH1 0x2 PUSH1 0x1 DUP2 SWAP1 SSTORE POP`

```
-----------a=1-----------
//60 01:将1压入栈中
PUSH1 0x01
	stack[0x01]
//60 00:将0压如栈中
PUSH1 0x00
	stack[0x01,0x00]
//81:复制栈中的第二项
DUP2
	stack[0x01,0x00,0x01]
//90:交换栈顶的两项数据
swap1
	stack[0x00,0x01,0x01]
//55:将数值0x01存储在0x00的位置上
sstore
  	stack[0x01]
  	store{0x00 => 0x01}
// 50:pop丢弃栈顶数据
pop
  	stack[]
  	store{0x00 => 0x01}
-----------b=2-----------
//60 02:将2压入栈中
PUSH1 0x02
	stack[0x02]
//60 00:将0压如栈中
PUSH1 0x01
	stack[0x02,0x01]
//81:复制栈中的第二项
DUP2
	stack[0x02,0x01,0x02]
//90:交换栈顶的两项数据
swap1
	stack[0x02,0x02,0x01]
//55:将数值0x02存储在0x01的位置上
sstore
  	stack[0x02]
  	store{0x01 => 0x02}
// 50:pop丢弃栈顶数据
pop
  	stack[]
  	store{0x01 => 0x02}
```

两个存储变量的存储位置是依次排列的，`a`在`0x00`的位置而`b`在`0x01`的位置。

----

### 4.solidity智能合约：存储打包

每个存储槽都可以存储32个字节。如果一个变量只需要16个字节但是使用全部的32个字节会很浪费。Solidity为了高效存储，提供了一个优化方案：如果可以的话，就将两个小一点的数据类型进行打包然后存储在一个存储槽中。

```solidity
pragma solidity ^0.4.11;
contract C {
    uint128 a;
    uint128 b;
    function C() {
      a = 1;
      b = 2;
    }
}
```
字节码：
```
6080604052348015600f57600080fd5b50

60016000806101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff160217905550
6002600060106101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff160217905550

60358060906000396000f3006080604052600080fd00a165627a7a72305820b72d23cfa4e9c3e3d84053a1446178dbc8bed69e0b710700036c74eaa4ce4ddc0029
```
编译代码:
```
PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH1 0xF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP 

PUSH1 0x1 PUSH1 0x0 DUP1 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH16 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH16 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR SWAP1 SSTORE POP
PUSH1 0x2 PUSH1 0x0 PUSH1 0x10 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH16 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH16 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR SWAP1 SSTORE POP

PUSH1 0x35 DUP1 PUSH1 0x90 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN STOP PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT STOP LOG1 PUSH6 0x627A7A723058 KECCAK256 0xb7 0x2d 0x23 0xcf LOG4 0xe9 0xc3 0xe3 0xd8 BLOCKHASH MSTORE8 LOG1 DIFFICULTY PUSH2 0x78DB 0xc8 0xbe 0xd6 SWAP15 SIGNEXTEND PUSH18 0x700036C74EAA4CE4DDC0029000000000000 
```

uint128  a=1,uint128  b=2字节码`60016000806101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff1602179055506002600060106101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff160217905550`
汇编代码`PUSH1 0x1 PUSH1 0x0 DUP1 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH16 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH16 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR SWAP1 SSTORE POP PUSH1 0x2 PUSH1 0x0 PUSH1 0x10 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH16 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH16 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR SWAP1 SSTORE POP`

```
-----------a=1-----------
//60 01:将0x01压入栈中
push 0x1
	stack[0x1]
//60 00:将0x0压入栈中
push 0x0
	stack[0x1,0x0]
//80:复制栈顶元素并压入栈
DUP1 
	stack[0x1,0x0,0x0]
//61 0100:将100压入栈中
PUSH2 
	stack[0x1,0x0,0x0,0x100]
//0a:取出100,0。100^0=1结果压入栈
EXP
	stack[0x1,0x0,0x1]
//81:复制栈内第二个元素并压入栈
DUP2
	stack[0x1,0x0,0x1,0x0]
//54:从0x0存储中读取值并压入栈中，因为0x0存储值并未初始化所以值为0x0。
SLOAD
	stack[0x1,0x0,0x1,0x0]
//81:复制栈内第二个元素并压入栈
DUP2
	stack[0x1,0x0,0x1,0x0,0x1]
//6f ffffffffffffffffffffffffffffffff:将0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF压入栈中
PUSH16 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	stack[0x1,0x0,0x1,0x0,0x1,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]
//02:计算0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF*0x1=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
MUL
	stack[0x1,0x0,0x1,0x0,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]
//19:0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF取反0x0
NOT
	stack[0x1,0x0,0x1,0x0,0x0]
//16:0x0&0x0:0x0
AND
	stack[0x1,0x0,0x1,0x0]
//90:第一个元素与第二个元素交换位置
SWAP1
	stack[0x1,0x0,0x0,0x1]
//83:复制第四个元素
DUP4
	stack[0x1,0x0,0x0,0x1,0x1]
//6f ffffffffffffffffffffffffffffffff:将0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF压入栈中
PUSH16 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	stack[0x1,0x0,0x0,0x1,0x1,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]
//16:0x1&0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF=0x1
AND
	stack[0x1,0x0,0x0,0x1,0x1]
//02:计算0x1*0x1=0x1
MUL
	stack[0x1,0x0,0x0,0x1]
//17:0x0|0x1=0x1
OR
	stack[0x1,0x0,0x1]
//90:第一个元素与第二个元素交换位置
SWAP1
	stack[0x1,0x1,0x0]
//55:将数值0x01存储在0x00的位置上
SSTORE
	stack[0x1]
	store{0x00 => 0x01}
//50:将栈中0x1丢弃
POP
	SSTORE
	store{0x00 => 0x01}
-----------b=1-----------
PUSH1 0x2
	stack[0x2]
PUSH1 0x0
	stack[0x2,0x0]
PUSH1 0x10
	stack[0x2,0x0,0x10]
PUSH2 0x100
	stack[0x2,0x0,0x10,0x100]
EXP
	stack[0x2,0x0,0x100^10]
DUP2
	stack[0x2,0x0,0x10000000000000000,0x0]
SLOAD
	stack[0x2,0x0,0x100000000000000000000000000000000,0x1]
DUP2
	stack[0x2,0x0,0x100^10,0x1,0x100^10]
PUSH16 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	stack[0x2,0x0,0x100^10,0x1,0x100000000000000000000000000000000,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]
MUL
	stack[0x2,0x0,0x100^10,0x1,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000]
NOT
	stack[0x2,0x0,0x100^10,0x1,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]
AND
	stack[0x2,0x0,0x100^10,0x1]
SWAP1
	stack[0x2,0x0,0x1,0x100^10]
DUP4
	stack[0x2,0x0,0x1,0x100^10,0x2]
PUSH16 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	stack[0x2,0x0,0x1,0x100^10,0x2,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF]
AND
	stack[0x2,0x0,0x1,0x100^10,0x2]
MUL
	stack[0x2,0x0,0x1,0x200^10]
OR
	stack[0x2,0x0,0x200000000000000000000000000000001]
SWAP1
	stack[0x2,0x200000000000000000000000000000001,0x0]
SSTORE
	stack[0x2]
	store{0x00 => 0x200000000000000000000000000000001}
POP
	stack[]
	store{0x00 => 0x200000000000000000000000000000001}
```

> **0x100^0x10=100000000000000000000000000000000**

>// 在字节码中表示为0x01
>16:32 0x00000000000000000000000000000000
>00:16 0x00000000000000000000000000000001

>//在字节码中表示为0x200000000000000000000000000000000 
>16:32 0x00000000000000000000000000000002
>00:16 0x00000000000000000000000000000000

进行打包的原因是因为目前最昂贵的操作就是存储的使用：

- `sstore`指令第一次写入一个新位置需要花费20000 gas
- `sstore`指令后续写入一个已存在的位置需要花费5000 gas
- `sload`指令的成本是500 gas
- 大多数的指令成本是3~10 gas

通过使用相同的存储位置，Solidity为存储第二个变量支付5000 gas，而不是20000 gas，节约了15000 gas。

